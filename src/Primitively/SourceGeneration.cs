using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Primitively;

/// <inheritdoc />
[Generator]
public class SourceGeneration : IIncrementalGenerator
{
    private const string EmbedAbstractions = "EMBED_PRIMITIVELY_ABSTRACTIONS";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
#if DEBUG
        if (!Debugger.IsAttached)
        {
            //Debugger.Launch();
        }
#endif
        Debug.WriteLine("Initalize code generator");

        // Register the abstractions sources
        context.RegisterPostInitializationOutput(ctx => GenerateSource(ctx));

        // Register the record struct sources
        var source = GetTargetSyntax(context);
        context.RegisterSourceOutput(source, (ctx, src) => GenerateSource(ctx, src.Compilation, src.RecordStructs));
    }

    private static void GenerateSource(IncrementalGeneratorPostInitializationContext context)
    {
        var sb = new StringBuilder();

        foreach (var resource in EmbeddedResources.Abstractions.GetEmbeddedResources())
        {
            sb.Clear();
            sb.Append(EmbeddedResources.AutoGeneratedHeader);
            sb.AppendLine();
            sb.AppendLine($"#if {EmbedAbstractions}");
            sb.AppendLine();
            sb.Append(resource.Value);
            sb.AppendLine();
            sb.AppendLine("#endif");

            var sourceText = SourceText.From(sb.ToString(), Encoding.UTF8);
            context.AddSource($"{resource.Key}.g.cs", sourceText);
        }
    }

    private static void GenerateSource(SourceProductionContext context, Compilation compilation, ImmutableArray<RecordDeclarationSyntax> recordStructs)
    {
        if (recordStructs.IsDefaultOrEmpty)
        {
            return;
        }

        var typesToGenerate = Parser.GetTypesToGenerate(compilation, recordStructs, context.ReportDiagnostic, context.CancellationToken);

        if (!typesToGenerate.Any())
        {
            return;
        }

        var sb = new StringBuilder();

        foreach (var type in typesToGenerate)
        {
            sb.Clear();
            sb.Append(EmbeddedResources.AutoGeneratedHeader);
            sb.AppendLine();
            sb.AppendLine($"namespace {type.NameSpace};");
            sb.AppendLine();
            sb.Append(EmbeddedResources.SystemTextJsonAttribute);
            sb.Append(EmbeddedResources.TypeConverterAttribute);
            sb.Append(EmbeddedResources.Guid.Base);
            sb.Append(EmbeddedResources.Guid.SystemTextJsonConverter);
            sb.Append(EmbeddedResources.Guid.TypeConverter);
            sb.AppendLine("}");

            var sourceText = SourceText.From(sb.Replace("ENCAPSULATED_PRIMITIVE_TYPE", type.Name).ToString(), Encoding.UTF8);
            context.AddSource($"{type.Name}.g.cs", sourceText);
        }
    }

    private static IncrementalValueProvider<(Compilation Compilation, ImmutableArray<RecordDeclarationSyntax> RecordStructs)> GetTargetSyntax(IncrementalGeneratorInitializationContext context)
    {
        // Create SyntaxProvider which sniffs out Record Structs decorated with a Primitively attribute
        IncrementalValuesProvider<RecordDeclarationSyntax> recordDeclarationSyntaxProvider = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => Parser.IsRecordStructTargetForGeneration(node),
                transform: static (context, cancellationToken) => Parser.GetRecordStructSemanticTargetForGeneration(context, cancellationToken))
            .Where(static m => m is not null)!;

        var targets = recordDeclarationSyntaxProvider.Collect();
        var compilationAndValues = context.CompilationProvider.Combine(targets);

        return compilationAndValues;
    }
}
